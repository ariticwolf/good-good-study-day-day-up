<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<script>
        // 适配方案 
        (function(window, document){
          function setRem() {
            let deviceWidth = document.documentElement.clientWidth;
            deviceWidth = deviceWidth > 680 ? 680 : deviceWidth;
            document.documentElement.style.fontSize = deviceWidth / 6.8 + "px";
          }
          setRem();
          window.addEventListener("resize", setRem);
          window.addEventListener('pageshow', function (e) {
            if (e.persisted) {
              setRem();
            }
          })
        })(window, document)
    </script>
	<style type="text/css">
		* {
			margin: 0;
			padding: 0;
		}
		::-webkit-scrollbar {
		    display: none;
		}
		[v-cloak] {
			display: none;
		}
		html, body {
			scroll-behavior: smooth;
		}
		#app {
			min-height: 100vh;
			width: 100wh;
			font-size: 0.2rem;
		}
		.banner {
			height: 2rem;
			background: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.nosdn.127.net%2FwulLPYPMjNJf6ea9JtDVudAtIm8%3DN6ir57o5DQzciZLUf1541332847502compressflag.jpg') no-repeat center / 100%;
		}
		.nav-tab-container {
		    height: 0.8rem;
		}
		.nav-tab {
			width: 100%;
			height: 0.8rem;
			position: relative;
			overflow-x: auto;
			scrollbar-width: none;
			/*scroll-behavior: smooth;*/
		}
		.nav-tab.fixed-top {
			background: #fff;
			position: fixed;
			top: 0;
			left: 0;
			z-index: 10;
		}
		.nav-list {
			height: 0.8rem;
			box-shadow: 0 0.17rem 0.24rem 0 rgba(211, 223, 237, 0.2);
			display: flex;
			position: absolute;
			left: 0;
			top: 0;
			white-space: nowrap;
		}
		.nav-item {
			margin: 0 0.3rem;
			color: #999;
			font-size: 0.26rem;
			font-weight: 500;
			display: flex;
			align-items: center;
		}
		.nav-item.active {
			color: #000;
			font-size: 0.3rem;
			font-weight: 800;
			border-bottom: 0.05rem solid #1890FF;
		}
		.class-info {
			height: 5rem;
			background: skyblue;
		}
		.teach-schedule-container {
			height: 5rem;
			background: blue;
		}
		.course-container-1 {
			height: 5rem;
			background: yellowgreen;
		}
		.course-container-2 {
			height: 5rem;
			background: darkred;
		}
		.finalexam-container {
			height: 5rem;
			background: green;
		}
		.score {
			height: 5rem;
			background: blanchedalmond;
		}
		.lesson {
			height: 5rem;
			background: pink;
		}
	</style>
</head>
<body>
	<div id="app" v-cloak>
		<div class="banner"></div>
		<div class="nav-tab-container" ref="navTabCon">
			<div class="nav-tab" :class="{'fixed-top': isFixedTop}">
				<ul class="nav-list">
					<li :class="['nav-item', {'active': currentTab===item.name}]" 
						v-for="item in navList"
						:key="item.type"
						@click="changeNavTab($event, item)">
						{{ item.name }}
					</li>
				</ul>
			</div>
		</div>
		<div class="class-info">分班信息</div>
		<div class="teach-schedule-container">授课日程</div>
		<div class="course-container-1">必修网课</div>
		<div class="course-container-2">选修网课</div>
		<div class="finalexam-container">结业考试</div>
		<div class="score">我的分数</div>
		<div class="lesson">我的课程</div>
		<div style="height: 600px;">bottom</div>
	</div>

	<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
	<script>
		new Vue({	
			el: '#app',
			data () {
				return {
					navList: [
						{ type: 1, name: '分班信息', component: '.class-info' },
						{ type: 2, name: '授课日程', component: '.teach-schedule-container' },
						{ type: 3, name: '必修网课', component: '.course-container-1' },
						{ type: 4, name: '选修网课', component: '.course-container-2' },
						{ type: 5, name: '结业考试', component: '.finalexam-container' },
						{ type: 6, name: '我的分数', component: '.score' },
						{ type: 7, name: '我的课程', component: '.lesson' }
					],
					currentTab: '分班信息',
          tabHeight: 0,
					isFixedTop: false, // 是否吸顶
					lockScroll: false, // 正在滚动事件 锚点不触发滚动标志
					animationIns: 0,
				}
			},
			watch: {
				currentTab (newVal, oldVal) {
					console.log(newVal, oldVal)
				}
			}, 
			mounted () {
				this.$nextTick(() => {
          this.tabHeight = document.querySelector('.nav-tab').getBoundingClientRect().height;

					window.addEventListener('scroll', this.stickyScroll);
					window.addEventListener('scroll', this.contentScroll)
				})
			},
			beforeDestroy() {
				window.removeEventListener('scroll', this.stickyScroll);
				window.removeEventListener('scroll', this.contentScroll);
			},
			methods: {
				// 滚动tab是否吸顶
				stickyScroll () {
					this.isFixedTop = this.$refs.navTabCon.getBoundingClientRect().top < 0
				},
				// 点击切换tab
				changeNavTab (e, info) {
					// console.log(info.name)
					if (this.currentTab === info.name) {
						return
					}
					this.currentTab = info.name

					
          this.scrollToCenter(e);
					this.scrollToCurrentContent(info);
				},
        // tab滚动居中
        scrollToCenter (e) {
          const _li = e.target
					const _navWraper = document.querySelector('.nav-tab')
					const _navWidth = _navWraper.getBoundingClientRect().width

					// tab横向居中滚动
					this.$nextTick(() => {
						const _liWidth = _li.getBoundingClientRect().width;
						const _liLeft = _li.offsetLeft;
						const _scrollLeft = _liLeft - (_navWidth - _liWidth) / 2;
						
						// console.log(_scrollLeft)
						// 方法一
						// _navWraper.scrollTo({
						// 	top: 0,
						// 	left: _scrollLeft,
						// 	behavior: 'smooth'
						// });
						// 方法二
						// _navWraper.scrollLeft = `${_scrollLeft}`
						// 方法三
						this.scrollViewLeft(_navWraper, _scrollLeft, 300)
					})
        },
        // 滚动到当前内容
        scrollToCurrentContent (info) {
          // 处理当前模块滑动距离
					const _navHeight = document.querySelector('.nav-tab').getBoundingClientRect().height
					const _node = document.querySelector(info.component)

					if (_node) {
						const _nodeTop = _node.offsetTop;
						const _nodeMarginTop = getComputedStyle(_node).marginTop;

						// 方法一
						// window.scrollTo({
						// 	top: _nodeTop - _navHeight - parseFloat(_nodeMarginTop),
						// 	left: 0,
						// 	behavior: 'smooth'
						// })
						const _scrollTop = _nodeTop - _navHeight - parseFloat(_nodeMarginTop)

						// console.log(_scrollTop, this.lockScroll)
						// 方法二
						const scrollEl = document.documentElement || document.body
						// scrollEl.scrollTop = `${_scrollTop}`
						// 方法三
						this.lockScroll = true
						this.scrollViewTop(scrollEl, _scrollTop, 300, () => {
							console.log('滚动执行完毕')
							this.lockScroll = false
						})
						console.log('>>>>锁住滚动', this.lockScroll)
					}
        },
				// 页面滑动处理函数
				contentScroll () {
					// console.log("----", this.lockScroll)
					if (this.lockScroll) {
						console.log('锁住滚动事件')
            return
					}
          console.log('window滚动了')
          const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
          const _navHeight = document.querySelector(".nav-tab").getBoundingClientRect().height
          // console.log(this.$refs.navTabCon.getBoundingClientRect().top, scrollTop)

          // 滚动页面切换相应tab
          this.navList.forEach(item => {
            const _conOffsetTop = document.querySelector(item.component).offsetTop
            // console.log(_conOffsetTop, scrollTop)
            if (_conOffsetTop - scrollTop <= _navHeight) {
              // console.log(item.name)
              document.title = item.name
              this.currentTab = item.name
              return
            }
          })
				},
				// 左右滚动
				scrollViewLeft (el, target, duration) {
					if (duration) {
						el.scrollTo({
							top: 0,
							left: target,
							behavior: 'smooth'
						})
					} else {
						el.scrollLeft = `${_scrollLeft}`
					}
				},
				// 上下滚动
				scrollViewTop (el, target, duration, callback) {
					const requestAnimationFrame = (
						window.requestAnimationFrame ||
						window.webkitRequestAnimationFrame ||
						window.mozRequestAnimationFrame ||
						window.msRequestAnimationFrame ||
						function (callback) {
						return window.setTimeout(callback, 1000 / 60)
						}
					);
					const cancelAnimationFrame = (
						window.cancelAnimationFrame ||
						function (id) {
							return window.clearTimeout(id)
						}
					);
		    	let currentOffset = el.scrollTop;
					let counts = 0;  // 记录滚动次数
					const steps = Math.round(duration / 30);  // 需要滚动次数
					const _scollDistance = target - currentOffset; // 需要滚动距离
					const frames = _scollDistance / steps;  // 每次滚动多远

					console.log(">>>", currentOffset, target, _scollDistance, steps, frames)

					// 如果duration为真 则有慢慢滚动
					if (duration) {
						const _moveFun = () => {
							currentOffset += frames
							el.scrollTop = currentOffset
							console.log(counts, currentOffset, el.scrollTop)
	            if (++counts < steps) {
	            	this.animationIns = requestAnimationFrame(_moveFun)
	            } else {
	            	callback && callback();
	            }
						}
						_moveFun()
					} else {
						el.scrollTo({
							left: 0,
							top: target
						})
					}
				}
			}
		})
	</script>
</body>
</html>